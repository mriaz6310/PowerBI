SELECT 
  'GRANT "' || pg_get_userbyid(roleid) || '" TO "' || pg_get_userbyid(member) || '";'
FROM pg_auth_members
WHERE pg_get_userbyid(roleid) NOT IN ('postgres', 'rdsadmin', 'rdsproxy')
  AND pg_get_userbyid(member) NOT IN ('postgres', 'rdsadmin', 'rdsproxy')
ORDER BY 1;


SELECT 
  'GRANT ' || privilege_type || ' ON "' || table_schema || '"."' || table_name || '" TO "' || grantee || '";'
FROM information_schema.role_table_grants
WHERE grantee NOT IN ('postgres', 'rdsadmin', 'rdsproxy')
ORDER BY grantee, table_schema, table_name;



SELECT 
  'GRANT USAGE ON SCHEMA "' || n.nspname || '" TO "' || r.rolname || '";'
FROM pg_roles r
CROSS JOIN pg_namespace n
WHERE n.nspname NOT LIKE 'pg_%'
  AND n.nspname <> 'information_schema'
  AND r.rolname NOT IN ('postgres', 'rdsadmin', 'rdsproxy')
ORDER BY 1;


SELECT 
  n.nspname AS schema_name,
  'postgrestestadm' AS grantee,
  has_schema_privilege('postgrestestadm', n.nspname, 'USAGE') AS has_usage,
  has_schema_privilege('postgrestestadm', n.nspname, 'CREATE') AS has_create
FROM pg_namespace n
WHERE n.nspname NOT LIKE 'pg_%'
  AND n.nspname <> 'information_schema'
ORDER BY n.nspname;






BEGIN
  rdsadmin.rdsadmin_util.create_directory(
    p_directory_name => 'DATA_PUMP_DIR'
  );
END;
/

-- Then run your Data Pump job via PL/SQL or SQL Developer


BEGIN
  rdsadmin.rdsadmin_util.export_rds_datafile(
    p_directory_name => 'DATA_PUMP_DIR',
    p_prefix         => 'my_export',
    p_parallel       => 2,
    p_compression    => 'ALL'
  );
END;
/






DECLARE
  l_dp_handle NUMBER;
BEGIN
  -- Open export job (FULL export)
  l_dp_handle := DBMS_DATAPUMP.OPEN(
    operation => 'EXPORT',
    job_mode  => 'FULL',
    job_name  => 'MY_EXPORT_JOB'
  );

  -- Add dump file
  DBMS_DATAPUMP.ADD_FILE(
    handle    => l_dp_handle,
    filename  => 'my_export.dmp',
    directory => 'DATA_PUMP_DIR'
  );

  -- Add log file
  DBMS_DATAPUMP.ADD_FILE(
    handle    => l_dp_handle,
    filename  => 'my_export.log',
    directory => 'DATA_PUMP_DIR',
    filetype  => DBMS_DATAPUMP.KU$_FILE_TYPE_LOG_FILE
  );

  -- Start job
  DBMS_DATAPUMP.START_JOB(l_dp_handle);

  -- Detach so job runs in background
  DBMS_DATAPUMP.DETACH(l_dp_handle);
END;
/


SELECT * FROM TABLE(RDSADMIN.RDS_FILE_UTIL.LISTDIR('DATA_PUMP_DIR'));

SELECT text FROM TABLE(RDSADMIN.RDS_FILE_UTIL.READ_TEXT_FILE('DATA_PUMP_DIR','MY_EXPORT.LOG'));



BEGIN
  rdsadmin.rdsadmin_util.download_to_s3(
    p_directory_name => 'DATA_PUMP_DIR',
    p_s3_bucket      => 'your-s3-bucket-name',         -- Change this to your bucket
    p_s3_prefix      => 'oracle_exports/',             -- Optional "folder" path inside bucket
    p_file_name      => 'my_export.dmp'                 -- The dump file name you want to upload
  );
END;
/



BEGIN
  DBMS_CLOUD.CREATE_CREDENTIAL(
    credential_name => 'MY_S3_CRED',
    username        => 'YOUR_AWS_ACCESS_KEY_ID',
    password        => 'YOUR_AWS_SECRET_ACCESS_KEY'
  );
END;
/


BEGIN
  DBMS_CLOUD.PUT_OBJECT(
    credential_name => 'MY_S3_CRED',
    object_uri      => 'https://s3.amazonaws.com/your-s3-bucket-name/oracle_exports/my_export.dmp',
    directory_name  => 'DATA_PUMP_DIR',
    file_name       => 'my_export.dmp'
  );
END;
/

"s3:PutObject",
"s3:GetObject",
"s3:DeleteObject"



export ORACLE_HOME=/opt/oracle/instantclient
export PATH=$ORACLE_HOME:$PATH
export LD_LIBRARY_PATH=$ORACLE_HOME


expdp DEVDB_USER/PASSWORD@//source-rds-endpoint:1521/ORCL \
dumpfile=/data/oracle_dumps/my_export_%U.dmp \
logfile=/data/oracle_dumps/my_export.log \
full=y \
parallel=4




SELECT table_schema, table_name
FROM information_schema.tables
WHERE table_schema = 'sde'
  AND table_name = 'gdb_release'
  AND table_catalog = 'geogajh';



DECLARE @name NVARCHAR(256);      -- database name
DECLARE @path NVARCHAR(512);      -- backup path
DECLARE @fileName NVARCHAR(512);  -- full .bak path
DECLARE @sql NVARCHAR(MAX);       -- dynamic SQL

-- Set your backup directory path (make sure this exists on the SQL Server host)
SET @path = 'C:\Backups\';

-- Cursor to loop through all user databases (exclude system DBs)
DECLARE db_cursor CURSOR FOR
SELECT name 
FROM sys.databases 
WHERE name NOT IN ('master', 'model', 'msdb', 'tempdb');

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @name;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @fileName = @path + @name + '.bak';

    SET @sql = '
    BACKUP DATABASE [' + @name + ']
    TO DISK = N''' + @fileName + '''
    WITH FORMAT,
         INIT,
         NAME = N''Full Backup of ' + @name + ''',
         COMPRESSION;
    ';
    
    PRINT 'Backing up: ' + @name;
    EXEC sp_executesql @sql;

    FETCH NEXT FROM db_cursor INTO @name;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;



ALTER DATABASE CART SET RECOVERY SIMPLE;
DBCC SHRINKFILE (
    (SELECT name FROM sys.master_files WHERE database_id = DB_ID('CART') AND type_desc = 'LOG'),
    1
);


BACKUP DATABASE [CART]
TO DISK = 'C:\Backups\CART.bak'
WITH FORMAT, INIT, NAME = 'Full Backup of CART', COMPRESSION;


SELECT 
    database_name,
    backup_start_date,
    backup_finish_date,
    type AS BackupType
FROM msdb.dbo.backupset
WHERE backup_start_date >= CAST(GETDATE() AS DATE)
  AND type = 'D'  -- D = Full backup
ORDER BY backup_start_date DESC;





SELECT 
    'EXEC master.dbo.sp_addlinkedserver 
        @server = N''' + name + ''', 
        @srvproduct = N''' + ISNULL(srvproduct, '') + ''', 
        @provider = N''' + ISNULL(provider, '') + ''', 
        @datasrc = N''' + ISNULL(data_source, '') + ''';'
FROM sys.servers
WHERE is_linked = 1;


SELECT 
    'EXEC master.dbo.sp_addlinkedsrvlogin 
        @rmtsrvname = N''' + s.name + ''', 
        @useself = ''' + CASE l.uses_self WHEN 1 THEN 'TRUE' ELSE 'FALSE' END + ''', 
        @locallogin = ' + 
            CASE 
                WHEN l.local_principal_id IS NULL THEN 'NULL' 
                ELSE 'N''' + p.name + '''' 
            END + ', 
        @rmtuser = N''' + ISNULL(l.remote_name, '') + ''', 
        @rmtpassword = N''' + ISNULL(l.remote_password, '') + ''';'
FROM sys.linked_logins l
JOIN sys.servers s ON l.server_id = s.server_id
LEFT JOIN sys.server_principals p ON l.local_principal_id = p.principal_id;



-- Use this script for each login
-- First, generate for all SQL logins
SELECT 'CREATE LOGIN [' + sp.name + '] WITH PASSWORD = 0x' + 
       CONVERT(VARCHAR(MAX), sl.password_hash, 2) + ' HASHED, CHECK_POLICY = OFF, DEFAULT_DATABASE = [' + sp.default_database_name + '];'
FROM sys.sql_logins AS sl
JOIN sys.server_principals AS sp ON sl.principal_id = sp.principal_id
WHERE sp.name NOT LIKE '##%';  -- exclude system-generated




-- Replace this with your own backup directory
DECLARE @BackupDir NVARCHAR(255) = N'D:\SQLBackups\';

-- Table of databases and their corresponding .bak files
DECLARE @Restores TABLE (
    DatabaseName NVARCHAR(128),
    BackupFile NVARCHAR(255)
);

-- Add your databases and .bak files here
INSERT INTO @Restores (DatabaseName, BackupFile)
VALUES 
    ('Database1', 'Database1.bak'),
    ('Database2', 'Database2.bak'),
    ('Database3', 'Database3.bak');
    -- Add more as needed

DECLARE @DBName NVARCHAR(128), @BackupFile NVARCHAR(255), @SQL NVARCHAR(MAX);

DECLARE restore_cursor CURSOR FOR
SELECT DatabaseName, BackupFile FROM @Restores;

OPEN restore_cursor;
FETCH NEXT FROM restore_cursor INTO @DBName, @BackupFile;

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT 'Restoring: ' + @DBName;

    SET @SQL = '
    RESTORE DATABASE [' + @DBName + ']
    FROM DISK = N''' + @BackupDir + @BackupFile + '''
    WITH 
        FILE = 1,
        MOVE ''' + @DBName + ''' TO ''D:\SQLData\' + @DBName + '.mdf'',
        MOVE ''' + @DBName + '_log'' TO ''D:\SQLLogs\' + @DBName + '_log.ldf'',
        REPLACE,
        STATS = 5;
    ';
    
    PRINT @SQL;
    EXEC sp_executesql @SQL;

    FETCH NEXT FROM restore_cursor INTO @DBName, @BackupFile;
END

CLOSE restore_cursor;
DEALLOCATE restore_cursor;



RESTORE FILELISTONLY 
FROM DISK = N'D:\SQLBackups\Database1.bak';



SELECT pg_get_functiondef(p.oid)
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE p.proname = 'abc_crop'
  AND n.nspname = 'car_dm';





SELECT
    n.nspname AS schema_name,
    p.proname AS function_name,
    pg_catalog.pg_get_function_identity_arguments(p.oid) AS arguments
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'car_dm'
  AND p.proname = 'abc_crop';




SELECT
    con.conname AS constraint_name,
    CASE con.contype
        WHEN 'p' THEN 'PRIMARY KEY'
        WHEN 'f' THEN 'FOREIGN KEY'
        WHEN 'u' THEN 'UNIQUE'
    END AS constraint_type,
    n.nspname AS schema_name,
    cl.relname AS table_name,
    string_agg(att.attname, ', ' ORDER BY att.attnum) AS column_names
FROM pg_constraint con
JOIN pg_class cl
    ON con.conrelid = cl.oid
JOIN pg_namespace n
    ON cl.relnamespace = n.oid
JOIN unnest(con.conkey) AS colnum
    JOIN pg_attribute att
        ON att.attrelid = cl.oid
       AND att.attnum = colnum
WHERE n.nspname = 'car_dm'
  AND con.contype IN ('p', 'f', 'u')
GROUP BY con.conname, con.contype, n.nspname, cl.relname
ORDER BY table_name, constraint_type;


SELECT
    c.relname AS constraint_name,
    CASE con.contype
        WHEN 'p' THEN 'PRIMARY KEY'
        WHEN 'f' THEN 'FOREIGN KEY'
        WHEN 'u' THEN 'UNIQUE'
    END AS constraint_type,
    ns.nspname AS schema_name,
    t.relname AS table_name,
    LISTAGG(a.attname, ', ') WITHIN GROUP (ORDER BY a.attnum) AS column_names
FROM pg_constraint con
JOIN pg_class t
    ON con.conrelid = t.oid
JOIN pg_namespace ns
    ON t.relnamespace = ns.oid
JOIN pg_class c
    ON con.oid = c.oid -- constraint name
JOIN pg_attribute a
    ON a.attrelid = t.oid
   AND a.attnum = ANY (con.conkey)
WHERE ns.nspname = 'car_dm'
  AND con.contype IN ('p', 'f', 'u')
GROUP BY c.relname, con.contype, ns.nspname, t.relname
ORDER BY table_name, constraint_type;


